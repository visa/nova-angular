/**
 *              Copyright (c) 2025 Visa, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 **/
import { EventEmitter, inject, Injectable, Output, QueryList, Renderer2, RendererFactory2 } from '@angular/core';
import { NavigationEnd, Router } from '@angular/router';
import { UUIDService } from '../lib/_utilities/services/uuid.service';
import { filter } from 'rxjs';
import { SafeSubscriber } from 'rxjs/internal/Subscriber';
import { AppReadyService } from './_utilities/services/app-stable-check.service';
import { ButtonDirective } from './button/button.directive';
import { CheckboxDirective } from './checkbox/checkbox.directive';
import { LinkDirective } from './link/link.directive';
import { ListboxItemComponent } from './listbox-item/listbox-item.component';
import { DOWN_ARROW_KEY, LEFT_ARROW_KEY, RIGHT_ARROW_KEY, TAB_KEY, UP_ARROW_KEY } from './nova-lib.constants';
import { TabItemDirective } from './tab-item/tab-item.directive';

/**
 * This service manages navigation states within the application, ensuring smooth transitions and a consistent user experience. <br />
 * Itâ€™s primarily used internally by the library but can also be leveraged directly for custom implementations.
 */
@Injectable({
  providedIn: 'root'
})
export class NovaLibService {
  constructor(
    private router: Router,
    private rendererFactory: RendererFactory2,
    private appReadyService: AppReadyService
  ) {
    this.renderer = rendererFactory.createRenderer(null, null);
  }

  /** @ignore */
  private _idService = inject(UUIDService);

  /** @ignore */
  private renderer: Renderer2;
  /**
   * The getUUID generates a random ID.
   * @deprecated Please use the equivalent method from our unique ID generator instead.
   * @param name Optional string to start the ID.
   * @returns string
   */
  getUUID(name?: string): string {
    return this._idService.getUUID(name);
  }

  /**
   * The check UUID method verifies that the given ID has not already been generated by the getUUID method. <br />
   * @deprecated Please use the equivalent method from our unique ID generator instead.
   * @param uuid String ID to check.
   * @param name Optional string to start the ID.
   * @returns uuid
   */
  checkUUID(uuid: string, name?: string): string {
    return this._idService.checkUUID(uuid, name);
  }

  /**
   * Emits new url on initial page load and page navigation; use alongside <code>getCurrentRoute</code>.
   */
  @Output() routeChange = new EventEmitter<string>();

  /**
   * The getCurrentRoute method can be used to retrieve the current route or to get updated URLs when routes change by subscribing to the <code>routeChange</code> event.
   * @returns router.url as string
   */
  getCurrentRoute(): string {
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd)).subscribe((event) => {
      this.routeChange.emit(this.router.url);
    });
    return this.router.url;
  }

  /**
   * The addArrowKeyNavigation method adds arrow key navigation to an array of elements of type <code>ButtonDirective</code>, <code>ListboxItemComponent</code>, <code>or CheckboxDirective</code>.
   * @param itemsArray Array of items to add arrow key navigation to.
   * @param arrowDirections Optionally specify which arrow key directions to use for navigation.
   * @param removeTabNavigation Optionally remove tab navigation from an array you're adding arrow navigation to.
   */
  addArrowKeyNavigation(
    itemsArray: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[],
    removeTabNavigation: boolean = false,
    arrowDirections: 'both' | 'horizontal' | 'vertical' = 'both'
  ) {
    if (!itemsArray || !itemsArray.length) return;
    itemsArray.forEach((item: ButtonDirective | ListboxItemComponent | CheckboxDirective, index: number) => {
      if (!item.el || !item.el.nativeElement) return;

      item.listeners.push(
        // for each button, add an event listener for arrow "keydown"
        this.renderer.listen(item.el.nativeElement, 'keydown', (event) => {
          // right and down arrow keys should go to next focusable item
          if (
            (event.key === DOWN_ARROW_KEY && arrowDirections !== 'horizontal') ||
            (event.key === RIGHT_ARROW_KEY && arrowDirections !== 'vertical')
          ) {
            event.preventDefault();
            const focusableIndex = this.nextEnabledItem(itemsArray, index);
            if (focusableIndex > -1) itemsArray[focusableIndex].el.nativeElement.focus();
          } else if (
            (event.key === UP_ARROW_KEY && arrowDirections !== 'horizontal') ||
            (event.key === LEFT_ARROW_KEY && arrowDirections !== 'vertical')
          ) {
            // left and up arrow keys should go to previous focusable item
            event.preventDefault();
            const focusableIndex = this.previousEnabledItem(itemsArray, index);
            if (focusableIndex > -1) itemsArray[focusableIndex].el.nativeElement.focus();
          }
        })
      );
    });

    if (removeTabNavigation) this.removeTabNavigation(itemsArray);
  }

  /**
   * The removeTabNavigation method removes tab navigation for an array of elements of type ButtonDirective, ListboxItemComponent, or CheckboxDirective. <br />
   * When this functionality is added, it will disable tabbing between these specified elements.
   * @param itemsArray Array of items to remove tab navigation from.
   */
  removeTabNavigation(itemsArray: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[]) {
    if (!itemsArray || !itemsArray.length) return;
    this.findStartingFocus(itemsArray);

    itemsArray.forEach((item: ButtonDirective | ListboxItemComponent | CheckboxDirective, index: number) => {
      if (!item.el || !item.el.nativeElement) return;

      item.listeners.push(
        this.renderer.listen(item.el.nativeElement, 'keydown', (event) => {
          // as you loop through the items with arrow keys, tabIndex must be updated so that only the item with focus has tabIndex = 0
          if (event.key === DOWN_ARROW_KEY || event.key === RIGHT_ARROW_KEY) {
            event.preventDefault(); // prevent scrolling
            const focusableIndex = this.nextEnabledItem(itemsArray, index);
            if (focusableIndex > -1) {
              this.renderer.setAttribute(item.el.nativeElement, 'tabIndex', '-1');
              this.renderer.setAttribute(itemsArray[focusableIndex].el.nativeElement, 'tabIndex', '0');
            }
          } else if (event.key === UP_ARROW_KEY || event.key === LEFT_ARROW_KEY) {
            event.preventDefault(); // prevent scrolling
            const focusableIndex = this.previousEnabledItem(itemsArray, index);
            if (focusableIndex > -1) {
              this.renderer.setAttribute(item.el.nativeElement, 'tabIndex', '-1');
              this.renderer.setAttribute(itemsArray[focusableIndex].el.nativeElement, 'tabIndex', '0');
            }
          } else if (event.key === TAB_KEY) {
            // if you tab out of the array, reset the starting index
            this.findStartingFocus(itemsArray);
          }
        })
      );
    });
  }

  /**
   * This method resets navigation behaviors for an array of elements of type <code>ButtonDirective</code>, <code>ListboxItemComponent</code>, or <code>CheckboxDirective</code>. <br />
   * It removes any tabindex or event listeners added by <code>addArrowKeyNavigation</code> or <code>removeTabNavigation</code>.
   * @param itemsArray Array of items to reset navigation behaviors for.
   */
  resetNavigationBehaviors(itemsArray: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[]) {
    if (!itemsArray || !itemsArray.length) return;
    itemsArray.forEach((item: ButtonDirective | ListboxItemComponent | CheckboxDirective, index: number) => {
      if (!item.el || !item.el.nativeElement) return;
      this.renderer.removeAttribute(item.el.nativeElement, 'tabIndex');
      item.listeners.forEach((listener) => {
        if (listener instanceof SafeSubscriber) {
          // unsubscribe from subscription
          listener.unsubscribe();
        } else {
          // remove event listener (if used with renderer.listen)
          listener();
        }
      });
      item.listeners = [];
    });
  }

  /**
   * The findStartingFocus method finds the item to start navigation on. <br />
   * The starting focusable item is either the first item or the currently selected item.
   * @param itemsArray Array of items to find starting focus for.
   */
  findStartingFocus(itemsArray: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[]) {
    if (!itemsArray || !itemsArray.length) return;
    // item.ariaSelected = button, item.active = listboxItem, item.checked = checkbox
    let selectedItemIndex = itemsArray.findIndex(
      (item: ButtonDirective | ListboxItemComponent | CheckboxDirective) =>
        ((item instanceof ButtonDirective && item.ariaSelected) ||
          (item instanceof ListboxItemComponent && item.active) ||
          (item instanceof CheckboxDirective && item.checked)) === true
    );
    if (selectedItemIndex === -1) selectedItemIndex = this.nextEnabledItem(itemsArray);
    itemsArray.forEach((item: ButtonDirective | ListboxItemComponent | CheckboxDirective, index: number) => {
      if (!item.el || !item.el.nativeElement) return;
      // if an item is the first / selected item, allow tab focus
      if (index === selectedItemIndex) {
        this.renderer.setAttribute(item.el.nativeElement, 'tabIndex', '0');
      } else {
        // otherwise remove tab focus ability
        this.renderer.setAttribute(item.el.nativeElement, 'tabIndex', '-1');
      }
    });
  }

  /**
   * The nextEnabledItem method finds the next item in the array that is not disabled. <br />
   * When this functionality is added, it will automatically skip over disabled items to locate the next enabled one.
   * @param items Array of items to search for next enabled item.
   * @param currentIndex Index to start searching from.
   * @returns Index of next item that is not disabled.
   */
  nextEnabledItem(
    items: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[],
    currentIndex?: number
  ): number {
    if (!items || !items.length) return -1;
    let index = currentIndex || currentIndex === 0 ? currentIndex + 1 : 0;
    let count = 0;
    while (count < items.length && index !== currentIndex) {
      if (index >= items.length) {
        index = 0;
      }
      if (!items[index].disabled) {
        return index;
      }
      index++;
      count++;
    }
    return index;
  }

  /**
   * The lastEnabledItem method retrieves the last item in an array that is not disabled.
   * @param items Array of items to search for last enabled item.
   * @returns Index of most last item that is not disabled.
   */
  lastEnabledItem(items: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[]): number {
    if (!items || !items.length) return -1;
    let count = items.length - 1;
    while (count >= 0) {
      if (items[count].disabled !== true) return count;
      count--;
    }
    return count;
  }

  /**
   * The firstEnabledItem methods retrieves the first item in array that is not disabled.
   * @param items Array of items to search for first enabled item.
   * @returns Index of first item that is not disabled.
   */
  firstEnabledItem(items: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[]): number {
    if (!items || !items.length) return -1;
    let count = 0;
    while (count < items.length) {
      if (items[count].disabled !== true) return count;
      count++;
    }
    return count;
  }

  /**
   * The previousEnabledItem method finds the previous item in the array that is not disabled. <br />
   * When this functionality is added, it will automatically skip over disabled items to locate the previous enabled one.
   * @param items Array of items to search for previous enabled item.
   * @param currentIndex Index to start reverse searching from.
   * @returns Index of first previous item that is not disabled.
   */
  previousEnabledItem(
    items: ButtonDirective[] | ListboxItemComponent[] | CheckboxDirective[],
    currentIndex?: number
  ): number {
    if (!items || !items.length) return -1;
    let index = currentIndex || currentIndex === 0 ? currentIndex - 1 : items.length - 1;
    let count = 0;
    while (count < items.length && index !== currentIndex) {
      if (index === -1) {
        index = items.length - 1;
      }
      if (!items[index].disabled) {
        return index;
      }
      index--;
      count++;
    }
    return index;
  }

  /**
   * The addAutomaticActivation method enables automatic tab activation for the specified tab or listbox list. <br />
   * When this functionality is added, focusing on an item will also select and activate it.
   * @param items Array of items to add automatic activation to.
   */
  addAutomaticActivation(items: TabItemDirective[] | ListboxItemComponent[]) {
    if (!items || !items.length) return;
    items.forEach((item: ListboxItemComponent | TabItemDirective, index: number) => {
      if (item instanceof TabItemDirective && item.button?.el?.nativeElement) {
        // tab button
        this.renderer.listen(item.button.el.nativeElement, 'focus', (event) => {
          this.selectItem(items, index);
        });
      } else if (item instanceof ListboxItemComponent && item._isRoleOptionVariant) {
        // standard list item
        this.renderer.listen(item.el.nativeElement, 'focus', (event) => {
          this.selectItem(items, index);
        });
      }
    });
  }

  /** @ignore */
  _currentLink: HTMLElement | null;
  /**
   * The setAriaCurrent method sets theÂ aria-current="true"Â attribute on the element with the specified ID.
   * @param id ID of element to set aria-current="true" on.
   */
  setAriaCurrent(id: string) {
    if (this._currentLink) {
      this.renderer.setAttribute(this._currentLink, 'aria-current', 'false');
    }
    const doc = this.appReadyService.checkDocumentExists();
    if (doc) {
      this._currentLink = document.getElementById(id);
      if (!this._currentLink) {
        console.warn('NovaLibService: setAriaCurrent could not find element with id: ' + id);
        return;
      }
      this.renderer.setAttribute(this._currentLink, 'aria-current', 'true');
    }
  }

  /**
   * The handleAriaCurrent method handles the aria-current value on click for a list of links.
   * @param links List of links to add aria-current functionality to.
   */
  handleAriaCurrent(links: LinkDirective[] | QueryList<LinkDirective>) {
    links.forEach((link) => {
      this.renderer.listen(link.el.nativeElement, 'click', () => {
        this.renderer.setAttribute(link.el.nativeElement, 'aria-current', 'true');
        links.forEach((item) => {
          if (item === link) return;
          this.renderer.setAttribute(item.el.nativeElement, 'aria-current', 'false');
        });
      });
    });
  }

  /**
   * The selectItems method selects items fromÂ start_indexÂ toÂ end_indexÂ in a list of tab or listbox items. By default, it selects all items if no indices are specified.
   * @param items Array of listbox items that you want to manipulate.
   * @param start Index of the first item you want to manipulate.
   * @param end Index of the last item you want to manipulate.
   * @param prop The property name you want to set to true (ie. active, highlighted, etc.). Defaults to 'active'.
   */
  selectItems(
    items: TabItemDirective[] | ListboxItemComponent[],
    start: number = 0,
    end: number = items.length - 1,
    prop: keyof TabItemDirective | keyof ListboxItemComponent = 'active'
  ) {
    if (!items || !items.length) return;
    if (start < 0 || end >= items.length || start > end) return;
    for (let i = start; i <= end; i++) {
      const item = items[i];
      if (item instanceof TabItemDirective) {
        if (item.button && !item.button.disabled) (item.button as any)[prop] = true;
      } else if (item instanceof ListboxItemComponent) {
        if (!item.disabled) (item as any)[prop] = true;
      }
    }
  }

  /**
   * The selectItem method selects an item from a list of tab or listbox items.
   * @param items List of items that contains the item you want to manipulate.
   * @param index Index of the item you want to manipulate.
   * @param prop The property name you want to set to true (ie. active, highlighted, etc.). Defaults to 'active'.
   */
  selectItem(
    items: TabItemDirective[] | ListboxItemComponent[],
    index: number,
    prop: keyof TabItemDirective | keyof ListboxItemComponent = 'active'
  ) {
    if (!items || !items.length) return;
    if (items[index]) {
      (items[index] as any)[prop] = true;
    }
  }

  /**
   * The deselectItems method deselect items out of a list of tab or listbox items.
   * @param items List of items that contains the items you want to manipulate.
   * @param index Optional index of the item you want to manipulate.
   * @param prop The property name you want to set to false (ie. active, highlighted, etc.). Defaults to 'active'.
   */
  deselectItems(
    items: TabItemDirective[] | ListboxItemComponent[],
    index?: number,
    prop: keyof TabItemDirective | keyof ListboxItemComponent = 'active'
  ) {
    if (!items || !items.length) return;
    items.forEach((item: TabItemDirective | ListboxItemComponent, i: number) => {
      if ((index || index === 0) && i === index) return;
      (item as any)[prop] = false;
    });
  }

  /**
   * The deselectItem method deselects a specific item from a list of tab or listbox items.
   * @param items List of items that contains the items you want to manipulate.
   * @param index Index of the item you want to manipulate.
   * @param prop The property name you want to set to false (ie. active, highlighted, etc.). Defaults to 'active'.
   */
  deselectItem(items: ListboxItemComponent[], index: number, prop: keyof ListboxItemComponent = 'active') {
    if (!items || !items.length) return;
    (items[index] as any)[prop] = false;
  }

  /**
   * The detectAllItemsSelected method checks whether all items in a given list of tab or listbox items are selected.
   * @param items List of items that contains the items you want to check.
   * @returns true if all items are selected, false if not.
   */
  detectAllItemsSelected(items: ListboxItemComponent[]) {
    if (!items || !items.length) return;
    let unSelectedItems = 0;
    items.forEach((item) => {
      if (!(item as any).active && !item.disabled) unSelectedItems++;
    });
    return unSelectedItems == 0;
  }
}
